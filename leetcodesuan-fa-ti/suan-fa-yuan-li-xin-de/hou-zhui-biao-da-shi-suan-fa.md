# 后缀表达式  
a b c * + d e * f + g * +  
优点：运用栈，机器非常好运行。当遇到操作符，就将栈中两个出栈计算后，再压栈
# 中缀表达式  
a + b * c + (d * e + f) * g 
优点：具有人的直观性，但应该转换为机器能运行的后缀表达式
*** 
#中缀表达式 -> 后缀表达式
中缀到后缀的转换
只允许操作符“+”、“*”、“(”、“)”。“(”进栈前优先级最高，在栈中优先级最低。 
> 算法描述：依次读入字符。当读到一个操作数的时候，立刻把它放到输出中；当读到操作符“+”、“*”、“(”中的任何一个，从栈中弹出栈元素直到发现优先级更低的元素为止，然后该操作符进栈；当读到操作符“)”时将元素弹出直到遇到一个对应的“(”。 
算法思想：栈代表挂起的操作符。在当前操作符要进栈之前，那些栈中比它优先级高或相等的操作符就应该弹出完成计算。 
例如，中缀表达式：a + b * c + (d * e + f) * g 
转换成后缀表达式是：a b c * + d e * f + g * +。过程如下： 

![](https://img-blog.csdn.net/20151126223357728)
![](https://img-blog.csdn.net/20151126223448309)
![](https://img-blog.csdn.net/20151126223519614)

#后缀表达式 -> 中缀表达式
> 算法描述:类似后缀求值算法，一次一个符号地读入表达式。如果符号是操作数，那么就建立一个单结点树并将它压入栈中；如果是操作符，那么就从栈中弹出两棵树T1和T2（T1先弹出）并形成一颗根为操作符的新树，它的左右儿子分别是T2和T1，然后将这颗新树压入栈中。 

![](https://img-blog.csdn.net/20151126230954860)
参考引用：
[后缀表达式及应用](https://blog.csdn.net/u011141102/article/details/50004101)